//go:build go1.22

// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package openapi

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Login
	// (POST /api/v1/auth/login)
	Login(w http.ResponseWriter, r *http.Request)
	// Current user profile
	// (GET /api/v1/auth/me)
	Me(w http.ResponseWriter, r *http.Request)
	// Register user
	// (POST /api/v1/auth/register)
	Register(w http.ResponseWriter, r *http.Request)
	// List connections
	// (GET /api/v1/connections)
	ListConnections(w http.ResponseWriter, r *http.Request, params ListConnectionsParams)
	// Create connection
	// (POST /api/v1/connections)
	CreateConnection(w http.ResponseWriter, r *http.Request, params CreateConnectionParams)
	// Delete connection
	// (DELETE /api/v1/connections/{id})
	DeleteConnection(w http.ResponseWriter, r *http.Request, id string, params DeleteConnectionParams)
	// Get connection
	// (GET /api/v1/connections/{id})
	GetConnection(w http.ResponseWriter, r *http.Request, id string, params GetConnectionParams)
	// Update connection
	// (PUT /api/v1/connections/{id})
	UpdateConnection(w http.ResponseWriter, r *http.Request, id string, params UpdateConnectionParams)
	// Ingest event
	// (POST /api/v1/events)
	IngestEvent(w http.ResponseWriter, r *http.Request, params IngestEventParams)
	// List job runs
	// (GET /api/v1/job_runs)
	ListJobRuns(w http.ResponseWriter, r *http.Request, params ListJobRunsParams)
	// Create job run
	// (POST /api/v1/job_runs)
	CreateJobRun(w http.ResponseWriter, r *http.Request, params CreateJobRunParams)
	// Get job run by ID
	// (GET /api/v1/job_runs/{id})
	GetJobRun(w http.ResponseWriter, r *http.Request, id string, params GetJobRunParams)
	// List jobs
	// (GET /api/v1/jobs)
	ListJobs(w http.ResponseWriter, r *http.Request, params ListJobsParams)
	// Create job
	// (POST /api/v1/jobs)
	CreateJob(w http.ResponseWriter, r *http.Request, params CreateJobParams)
	// Get job
	// (GET /api/v1/jobs/{id})
	GetJob(w http.ResponseWriter, r *http.Request, id string, params GetJobParams)
	// Update job
	// (PUT /api/v1/jobs/{id})
	UpdateJob(w http.ResponseWriter, r *http.Request, id string, params UpdateJobParams)
	// List job versions
	// (GET /api/v1/jobs/{job_id}/versions)
	ListJobVersions(w http.ResponseWriter, r *http.Request, jobId string, params ListJobVersionsParams)
	// Create job version (with modules and edges)
	// (POST /api/v1/jobs/{job_id}/versions)
	CreateJobVersion(w http.ResponseWriter, r *http.Request, jobId string, params CreateJobVersionParams)
	// Get job version detail (with modules and edges)
	// (GET /api/v1/jobs/{job_id}/versions/{version_id})
	GetJobVersionDetail(w http.ResponseWriter, r *http.Request, jobId string, versionId string, params GetJobVersionDetailParams)
	// Publish job version
	// (POST /api/v1/jobs/{job_id}/versions/{version_id}/publish)
	PublishJobVersion(w http.ResponseWriter, r *http.Request, jobId string, versionId string, params PublishJobVersionParams)
	// List module types
	// (GET /api/v1/module_types)
	ListModuleTypes(w http.ResponseWriter, r *http.Request, params ListModuleTypesParams)
	// Create module type
	// (POST /api/v1/module_types)
	CreateModuleType(w http.ResponseWriter, r *http.Request, params CreateModuleTypeParams)
	// Get module type
	// (GET /api/v1/module_types/{id})
	GetModuleType(w http.ResponseWriter, r *http.Request, id string, params GetModuleTypeParams)
	// List module type schema versions
	// (GET /api/v1/module_types/{id}/schemas)
	ListModuleTypeSchemas(w http.ResponseWriter, r *http.Request, id string, params ListModuleTypeSchemasParams)
	// Create module type schema version
	// (POST /api/v1/module_types/{id}/schemas)
	CreateModuleTypeSchema(w http.ResponseWriter, r *http.Request, id string, params CreateModuleTypeSchemaParams)
	// Health check
	// (GET /healthz)
	GetHealthz(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// Login operation middleware
func (siw *ServerInterfaceWrapper) Login(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Login(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Me operation middleware
func (siw *ServerInterfaceWrapper) Me(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Me(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Register operation middleware
func (siw *ServerInterfaceWrapper) Register(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Register(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListConnections operation middleware
func (siw *ServerInterfaceWrapper) ListConnections(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListConnectionsParams

	headers := r.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID XTenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Tenant-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Tenant-ID", Err: err})
			return
		}

		params.XTenantID = XTenantID

	} else {
		err := fmt.Errorf("Header parameter X-Tenant-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Tenant-ID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListConnections(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateConnection operation middleware
func (siw *ServerInterfaceWrapper) CreateConnection(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateConnectionParams

	headers := r.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID XTenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Tenant-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Tenant-ID", Err: err})
			return
		}

		params.XTenantID = XTenantID

	} else {
		err := fmt.Errorf("Header parameter X-Tenant-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Tenant-ID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateConnection(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteConnection operation middleware
func (siw *ServerInterfaceWrapper) DeleteConnection(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteConnectionParams

	headers := r.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID XTenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Tenant-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Tenant-ID", Err: err})
			return
		}

		params.XTenantID = XTenantID

	} else {
		err := fmt.Errorf("Header parameter X-Tenant-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Tenant-ID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteConnection(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetConnection operation middleware
func (siw *ServerInterfaceWrapper) GetConnection(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetConnectionParams

	headers := r.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID XTenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Tenant-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Tenant-ID", Err: err})
			return
		}

		params.XTenantID = XTenantID

	} else {
		err := fmt.Errorf("Header parameter X-Tenant-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Tenant-ID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetConnection(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateConnection operation middleware
func (siw *ServerInterfaceWrapper) UpdateConnection(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateConnectionParams

	headers := r.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID XTenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Tenant-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Tenant-ID", Err: err})
			return
		}

		params.XTenantID = XTenantID

	} else {
		err := fmt.Errorf("Header parameter X-Tenant-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Tenant-ID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateConnection(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// IngestEvent operation middleware
func (siw *ServerInterfaceWrapper) IngestEvent(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params IngestEventParams

	headers := r.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID XTenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Tenant-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Tenant-ID", Err: err})
			return
		}

		params.XTenantID = XTenantID

	} else {
		err := fmt.Errorf("Header parameter X-Tenant-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Tenant-ID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.IngestEvent(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListJobRuns operation middleware
func (siw *ServerInterfaceWrapper) ListJobRuns(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListJobRunsParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID XTenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Tenant-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Tenant-ID", Err: err})
			return
		}

		params.XTenantID = XTenantID

	} else {
		err := fmt.Errorf("Header parameter X-Tenant-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Tenant-ID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListJobRuns(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateJobRun operation middleware
func (siw *ServerInterfaceWrapper) CreateJobRun(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateJobRunParams

	headers := r.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID XTenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Tenant-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Tenant-ID", Err: err})
			return
		}

		params.XTenantID = XTenantID

	} else {
		err := fmt.Errorf("Header parameter X-Tenant-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Tenant-ID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateJobRun(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetJobRun operation middleware
func (siw *ServerInterfaceWrapper) GetJobRun(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetJobRunParams

	headers := r.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID XTenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Tenant-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Tenant-ID", Err: err})
			return
		}

		params.XTenantID = XTenantID

	} else {
		err := fmt.Errorf("Header parameter X-Tenant-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Tenant-ID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetJobRun(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListJobs operation middleware
func (siw *ServerInterfaceWrapper) ListJobs(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListJobsParams

	headers := r.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID XTenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Tenant-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Tenant-ID", Err: err})
			return
		}

		params.XTenantID = XTenantID

	} else {
		err := fmt.Errorf("Header parameter X-Tenant-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Tenant-ID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListJobs(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateJob operation middleware
func (siw *ServerInterfaceWrapper) CreateJob(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateJobParams

	headers := r.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID XTenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Tenant-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Tenant-ID", Err: err})
			return
		}

		params.XTenantID = XTenantID

	} else {
		err := fmt.Errorf("Header parameter X-Tenant-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Tenant-ID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateJob(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetJob operation middleware
func (siw *ServerInterfaceWrapper) GetJob(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetJobParams

	headers := r.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID XTenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Tenant-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Tenant-ID", Err: err})
			return
		}

		params.XTenantID = XTenantID

	} else {
		err := fmt.Errorf("Header parameter X-Tenant-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Tenant-ID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetJob(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateJob operation middleware
func (siw *ServerInterfaceWrapper) UpdateJob(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateJobParams

	headers := r.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID XTenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Tenant-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Tenant-ID", Err: err})
			return
		}

		params.XTenantID = XTenantID

	} else {
		err := fmt.Errorf("Header parameter X-Tenant-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Tenant-ID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateJob(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListJobVersions operation middleware
func (siw *ServerInterfaceWrapper) ListJobVersions(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "job_id" -------------
	var jobId string

	err = runtime.BindStyledParameterWithOptions("simple", "job_id", r.PathValue("job_id"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "job_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListJobVersionsParams

	headers := r.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID XTenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Tenant-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Tenant-ID", Err: err})
			return
		}

		params.XTenantID = XTenantID

	} else {
		err := fmt.Errorf("Header parameter X-Tenant-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Tenant-ID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListJobVersions(w, r, jobId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateJobVersion operation middleware
func (siw *ServerInterfaceWrapper) CreateJobVersion(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "job_id" -------------
	var jobId string

	err = runtime.BindStyledParameterWithOptions("simple", "job_id", r.PathValue("job_id"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "job_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateJobVersionParams

	headers := r.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID XTenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Tenant-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Tenant-ID", Err: err})
			return
		}

		params.XTenantID = XTenantID

	} else {
		err := fmt.Errorf("Header parameter X-Tenant-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Tenant-ID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateJobVersion(w, r, jobId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetJobVersionDetail operation middleware
func (siw *ServerInterfaceWrapper) GetJobVersionDetail(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "job_id" -------------
	var jobId string

	err = runtime.BindStyledParameterWithOptions("simple", "job_id", r.PathValue("job_id"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "job_id", Err: err})
		return
	}

	// ------------- Path parameter "version_id" -------------
	var versionId string

	err = runtime.BindStyledParameterWithOptions("simple", "version_id", r.PathValue("version_id"), &versionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "version_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetJobVersionDetailParams

	headers := r.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID XTenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Tenant-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Tenant-ID", Err: err})
			return
		}

		params.XTenantID = XTenantID

	} else {
		err := fmt.Errorf("Header parameter X-Tenant-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Tenant-ID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetJobVersionDetail(w, r, jobId, versionId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PublishJobVersion operation middleware
func (siw *ServerInterfaceWrapper) PublishJobVersion(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "job_id" -------------
	var jobId string

	err = runtime.BindStyledParameterWithOptions("simple", "job_id", r.PathValue("job_id"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "job_id", Err: err})
		return
	}

	// ------------- Path parameter "version_id" -------------
	var versionId string

	err = runtime.BindStyledParameterWithOptions("simple", "version_id", r.PathValue("version_id"), &versionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "version_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PublishJobVersionParams

	headers := r.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID XTenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Tenant-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Tenant-ID", Err: err})
			return
		}

		params.XTenantID = XTenantID

	} else {
		err := fmt.Errorf("Header parameter X-Tenant-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Tenant-ID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PublishJobVersion(w, r, jobId, versionId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListModuleTypes operation middleware
func (siw *ServerInterfaceWrapper) ListModuleTypes(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListModuleTypesParams

	headers := r.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID XTenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Tenant-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Tenant-ID", Err: err})
			return
		}

		params.XTenantID = XTenantID

	} else {
		err := fmt.Errorf("Header parameter X-Tenant-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Tenant-ID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListModuleTypes(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateModuleType operation middleware
func (siw *ServerInterfaceWrapper) CreateModuleType(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateModuleTypeParams

	headers := r.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID XTenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Tenant-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Tenant-ID", Err: err})
			return
		}

		params.XTenantID = XTenantID

	} else {
		err := fmt.Errorf("Header parameter X-Tenant-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Tenant-ID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateModuleType(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetModuleType operation middleware
func (siw *ServerInterfaceWrapper) GetModuleType(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetModuleTypeParams

	headers := r.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID XTenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Tenant-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Tenant-ID", Err: err})
			return
		}

		params.XTenantID = XTenantID

	} else {
		err := fmt.Errorf("Header parameter X-Tenant-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Tenant-ID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetModuleType(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListModuleTypeSchemas operation middleware
func (siw *ServerInterfaceWrapper) ListModuleTypeSchemas(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListModuleTypeSchemasParams

	headers := r.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID XTenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Tenant-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Tenant-ID", Err: err})
			return
		}

		params.XTenantID = XTenantID

	} else {
		err := fmt.Errorf("Header parameter X-Tenant-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Tenant-ID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListModuleTypeSchemas(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateModuleTypeSchema operation middleware
func (siw *ServerInterfaceWrapper) CreateModuleTypeSchema(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateModuleTypeSchemaParams

	headers := r.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID XTenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Tenant-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Tenant-ID", Err: err})
			return
		}

		params.XTenantID = XTenantID

	} else {
		err := fmt.Errorf("Header parameter X-Tenant-ID is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-Tenant-ID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateModuleTypeSchema(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetHealthz operation middleware
func (siw *ServerInterfaceWrapper) GetHealthz(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetHealthz(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("POST "+options.BaseURL+"/api/v1/auth/login", wrapper.Login)
	m.HandleFunc("GET "+options.BaseURL+"/api/v1/auth/me", wrapper.Me)
	m.HandleFunc("POST "+options.BaseURL+"/api/v1/auth/register", wrapper.Register)
	m.HandleFunc("GET "+options.BaseURL+"/api/v1/connections", wrapper.ListConnections)
	m.HandleFunc("POST "+options.BaseURL+"/api/v1/connections", wrapper.CreateConnection)
	m.HandleFunc("DELETE "+options.BaseURL+"/api/v1/connections/{id}", wrapper.DeleteConnection)
	m.HandleFunc("GET "+options.BaseURL+"/api/v1/connections/{id}", wrapper.GetConnection)
	m.HandleFunc("PUT "+options.BaseURL+"/api/v1/connections/{id}", wrapper.UpdateConnection)
	m.HandleFunc("POST "+options.BaseURL+"/api/v1/events", wrapper.IngestEvent)
	m.HandleFunc("GET "+options.BaseURL+"/api/v1/job_runs", wrapper.ListJobRuns)
	m.HandleFunc("POST "+options.BaseURL+"/api/v1/job_runs", wrapper.CreateJobRun)
	m.HandleFunc("GET "+options.BaseURL+"/api/v1/job_runs/{id}", wrapper.GetJobRun)
	m.HandleFunc("GET "+options.BaseURL+"/api/v1/jobs", wrapper.ListJobs)
	m.HandleFunc("POST "+options.BaseURL+"/api/v1/jobs", wrapper.CreateJob)
	m.HandleFunc("GET "+options.BaseURL+"/api/v1/jobs/{id}", wrapper.GetJob)
	m.HandleFunc("PUT "+options.BaseURL+"/api/v1/jobs/{id}", wrapper.UpdateJob)
	m.HandleFunc("GET "+options.BaseURL+"/api/v1/jobs/{job_id}/versions", wrapper.ListJobVersions)
	m.HandleFunc("POST "+options.BaseURL+"/api/v1/jobs/{job_id}/versions", wrapper.CreateJobVersion)
	m.HandleFunc("GET "+options.BaseURL+"/api/v1/jobs/{job_id}/versions/{version_id}", wrapper.GetJobVersionDetail)
	m.HandleFunc("POST "+options.BaseURL+"/api/v1/jobs/{job_id}/versions/{version_id}/publish", wrapper.PublishJobVersion)
	m.HandleFunc("GET "+options.BaseURL+"/api/v1/module_types", wrapper.ListModuleTypes)
	m.HandleFunc("POST "+options.BaseURL+"/api/v1/module_types", wrapper.CreateModuleType)
	m.HandleFunc("GET "+options.BaseURL+"/api/v1/module_types/{id}", wrapper.GetModuleType)
	m.HandleFunc("GET "+options.BaseURL+"/api/v1/module_types/{id}/schemas", wrapper.ListModuleTypeSchemas)
	m.HandleFunc("POST "+options.BaseURL+"/api/v1/module_types/{id}/schemas", wrapper.CreateModuleTypeSchema)
	m.HandleFunc("GET "+options.BaseURL+"/healthz", wrapper.GetHealthz)

	return m
}

type ErrorResponseJSONResponse ErrorResponse

type LoginRequestObject struct {
	Body *LoginJSONRequestBody
}

type LoginResponseObject interface {
	VisitLoginResponse(w http.ResponseWriter) error
}

type Login200JSONResponse LoginResponse

func (response Login200JSONResponse) VisitLoginResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type Login400JSONResponse struct{ ErrorResponseJSONResponse }

func (response Login400JSONResponse) VisitLoginResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type Login401JSONResponse ErrorResponse

func (response Login401JSONResponse) VisitLoginResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type MeRequestObject struct {
}

type MeResponseObject interface {
	VisitMeResponse(w http.ResponseWriter) error
}

type Me200JSONResponse MeResponse

func (response Me200JSONResponse) VisitMeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type Me401JSONResponse struct{ ErrorResponseJSONResponse }

func (response Me401JSONResponse) VisitMeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type RegisterRequestObject struct {
	Body *RegisterJSONRequestBody
}

type RegisterResponseObject interface {
	VisitRegisterResponse(w http.ResponseWriter) error
}

type Register201JSONResponse RegisterResponse

func (response Register201JSONResponse) VisitRegisterResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type Register400JSONResponse struct{ ErrorResponseJSONResponse }

func (response Register400JSONResponse) VisitRegisterResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type Register409JSONResponse ErrorResponse

func (response Register409JSONResponse) VisitRegisterResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type ListConnectionsRequestObject struct {
	Params ListConnectionsParams
}

type ListConnectionsResponseObject interface {
	VisitListConnectionsResponse(w http.ResponseWriter) error
}

type ListConnections200JSONResponse struct {
	Items []Connection `json:"items"`
}

func (response ListConnections200JSONResponse) VisitListConnectionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListConnections401JSONResponse struct{ ErrorResponseJSONResponse }

func (response ListConnections401JSONResponse) VisitListConnectionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type CreateConnectionRequestObject struct {
	Params CreateConnectionParams
	Body   *CreateConnectionJSONRequestBody
}

type CreateConnectionResponseObject interface {
	VisitCreateConnectionResponse(w http.ResponseWriter) error
}

type CreateConnection201JSONResponse Connection

func (response CreateConnection201JSONResponse) VisitCreateConnectionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type CreateConnection400JSONResponse struct{ ErrorResponseJSONResponse }

func (response CreateConnection400JSONResponse) VisitCreateConnectionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreateConnection401JSONResponse ErrorResponse

func (response CreateConnection401JSONResponse) VisitCreateConnectionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type CreateConnection409JSONResponse ErrorResponse

func (response CreateConnection409JSONResponse) VisitCreateConnectionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type DeleteConnectionRequestObject struct {
	Id     string `json:"id"`
	Params DeleteConnectionParams
}

type DeleteConnectionResponseObject interface {
	VisitDeleteConnectionResponse(w http.ResponseWriter) error
}

type DeleteConnection204Response struct {
}

func (response DeleteConnection204Response) VisitDeleteConnectionResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteConnection401JSONResponse struct{ ErrorResponseJSONResponse }

func (response DeleteConnection401JSONResponse) VisitDeleteConnectionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type DeleteConnection404JSONResponse ErrorResponse

func (response DeleteConnection404JSONResponse) VisitDeleteConnectionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetConnectionRequestObject struct {
	Id     string `json:"id"`
	Params GetConnectionParams
}

type GetConnectionResponseObject interface {
	VisitGetConnectionResponse(w http.ResponseWriter) error
}

type GetConnection200JSONResponse Connection

func (response GetConnection200JSONResponse) VisitGetConnectionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetConnection401JSONResponse struct{ ErrorResponseJSONResponse }

func (response GetConnection401JSONResponse) VisitGetConnectionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetConnection404JSONResponse ErrorResponse

func (response GetConnection404JSONResponse) VisitGetConnectionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type UpdateConnectionRequestObject struct {
	Id     string `json:"id"`
	Params UpdateConnectionParams
	Body   *UpdateConnectionJSONRequestBody
}

type UpdateConnectionResponseObject interface {
	VisitUpdateConnectionResponse(w http.ResponseWriter) error
}

type UpdateConnection200JSONResponse Connection

func (response UpdateConnection200JSONResponse) VisitUpdateConnectionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdateConnection400JSONResponse struct{ ErrorResponseJSONResponse }

func (response UpdateConnection400JSONResponse) VisitUpdateConnectionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type UpdateConnection401JSONResponse ErrorResponse

func (response UpdateConnection401JSONResponse) VisitUpdateConnectionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type UpdateConnection404JSONResponse ErrorResponse

func (response UpdateConnection404JSONResponse) VisitUpdateConnectionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type UpdateConnection409JSONResponse ErrorResponse

func (response UpdateConnection409JSONResponse) VisitUpdateConnectionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type IngestEventRequestObject struct {
	Params IngestEventParams
	Body   *IngestEventJSONRequestBody
}

type IngestEventResponseObject interface {
	VisitIngestEventResponse(w http.ResponseWriter) error
}

type IngestEvent202JSONResponse IngestEventResponse

func (response IngestEvent202JSONResponse) VisitIngestEventResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(202)

	return json.NewEncoder(w).Encode(response)
}

type IngestEvent400JSONResponse struct{ ErrorResponseJSONResponse }

func (response IngestEvent400JSONResponse) VisitIngestEventResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type IngestEvent401JSONResponse ErrorResponse

func (response IngestEvent401JSONResponse) VisitIngestEventResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type IngestEvent409JSONResponse ErrorResponse

func (response IngestEvent409JSONResponse) VisitIngestEventResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type ListJobRunsRequestObject struct {
	Params ListJobRunsParams
}

type ListJobRunsResponseObject interface {
	VisitListJobRunsResponse(w http.ResponseWriter) error
}

type ListJobRuns200JSONResponse struct {
	Items []JobRun `json:"items"`
}

func (response ListJobRuns200JSONResponse) VisitListJobRunsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListJobRuns401JSONResponse struct{ ErrorResponseJSONResponse }

func (response ListJobRuns401JSONResponse) VisitListJobRunsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type CreateJobRunRequestObject struct {
	Params CreateJobRunParams
	Body   *CreateJobRunJSONRequestBody
}

type CreateJobRunResponseObject interface {
	VisitCreateJobRunResponse(w http.ResponseWriter) error
}

type CreateJobRun201JSONResponse JobRun

func (response CreateJobRun201JSONResponse) VisitCreateJobRunResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type CreateJobRun401JSONResponse struct{ ErrorResponseJSONResponse }

func (response CreateJobRun401JSONResponse) VisitCreateJobRunResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetJobRunRequestObject struct {
	Id     string `json:"id"`
	Params GetJobRunParams
}

type GetJobRunResponseObject interface {
	VisitGetJobRunResponse(w http.ResponseWriter) error
}

type GetJobRun200JSONResponse JobRun

func (response GetJobRun200JSONResponse) VisitGetJobRunResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetJobRun401JSONResponse struct{ ErrorResponseJSONResponse }

func (response GetJobRun401JSONResponse) VisitGetJobRunResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetJobRun404JSONResponse ErrorResponse

func (response GetJobRun404JSONResponse) VisitGetJobRunResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ListJobsRequestObject struct {
	Params ListJobsParams
}

type ListJobsResponseObject interface {
	VisitListJobsResponse(w http.ResponseWriter) error
}

type ListJobs200JSONResponse struct {
	Items []Job `json:"items"`
}

func (response ListJobs200JSONResponse) VisitListJobsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListJobs401JSONResponse struct{ ErrorResponseJSONResponse }

func (response ListJobs401JSONResponse) VisitListJobsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type CreateJobRequestObject struct {
	Params CreateJobParams
	Body   *CreateJobJSONRequestBody
}

type CreateJobResponseObject interface {
	VisitCreateJobResponse(w http.ResponseWriter) error
}

type CreateJob201JSONResponse Job

func (response CreateJob201JSONResponse) VisitCreateJobResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type CreateJob400JSONResponse struct{ ErrorResponseJSONResponse }

func (response CreateJob400JSONResponse) VisitCreateJobResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreateJob401JSONResponse ErrorResponse

func (response CreateJob401JSONResponse) VisitCreateJobResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type CreateJob409JSONResponse ErrorResponse

func (response CreateJob409JSONResponse) VisitCreateJobResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type GetJobRequestObject struct {
	Id     string `json:"id"`
	Params GetJobParams
}

type GetJobResponseObject interface {
	VisitGetJobResponse(w http.ResponseWriter) error
}

type GetJob200JSONResponse Job

func (response GetJob200JSONResponse) VisitGetJobResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetJob401JSONResponse struct{ ErrorResponseJSONResponse }

func (response GetJob401JSONResponse) VisitGetJobResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetJob404JSONResponse ErrorResponse

func (response GetJob404JSONResponse) VisitGetJobResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type UpdateJobRequestObject struct {
	Id     string `json:"id"`
	Params UpdateJobParams
	Body   *UpdateJobJSONRequestBody
}

type UpdateJobResponseObject interface {
	VisitUpdateJobResponse(w http.ResponseWriter) error
}

type UpdateJob200JSONResponse Job

func (response UpdateJob200JSONResponse) VisitUpdateJobResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdateJob400JSONResponse struct{ ErrorResponseJSONResponse }

func (response UpdateJob400JSONResponse) VisitUpdateJobResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type UpdateJob401JSONResponse ErrorResponse

func (response UpdateJob401JSONResponse) VisitUpdateJobResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type UpdateJob404JSONResponse ErrorResponse

func (response UpdateJob404JSONResponse) VisitUpdateJobResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type UpdateJob409JSONResponse ErrorResponse

func (response UpdateJob409JSONResponse) VisitUpdateJobResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type ListJobVersionsRequestObject struct {
	JobId  string `json:"job_id"`
	Params ListJobVersionsParams
}

type ListJobVersionsResponseObject interface {
	VisitListJobVersionsResponse(w http.ResponseWriter) error
}

type ListJobVersions200JSONResponse struct {
	Items []JobVersion `json:"items"`
}

func (response ListJobVersions200JSONResponse) VisitListJobVersionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListJobVersions401JSONResponse struct{ ErrorResponseJSONResponse }

func (response ListJobVersions401JSONResponse) VisitListJobVersionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type CreateJobVersionRequestObject struct {
	JobId  string `json:"job_id"`
	Params CreateJobVersionParams
	Body   *CreateJobVersionJSONRequestBody
}

type CreateJobVersionResponseObject interface {
	VisitCreateJobVersionResponse(w http.ResponseWriter) error
}

type CreateJobVersion201JSONResponse JobVersion

func (response CreateJobVersion201JSONResponse) VisitCreateJobVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type CreateJobVersion400JSONResponse struct{ ErrorResponseJSONResponse }

func (response CreateJobVersion400JSONResponse) VisitCreateJobVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreateJobVersion401JSONResponse ErrorResponse

func (response CreateJobVersion401JSONResponse) VisitCreateJobVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type CreateJobVersion404JSONResponse ErrorResponse

func (response CreateJobVersion404JSONResponse) VisitCreateJobVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetJobVersionDetailRequestObject struct {
	JobId     string `json:"job_id"`
	VersionId string `json:"version_id"`
	Params    GetJobVersionDetailParams
}

type GetJobVersionDetailResponseObject interface {
	VisitGetJobVersionDetailResponse(w http.ResponseWriter) error
}

type GetJobVersionDetail200JSONResponse JobVersionDetail

func (response GetJobVersionDetail200JSONResponse) VisitGetJobVersionDetailResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetJobVersionDetail401JSONResponse struct{ ErrorResponseJSONResponse }

func (response GetJobVersionDetail401JSONResponse) VisitGetJobVersionDetailResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetJobVersionDetail404JSONResponse ErrorResponse

func (response GetJobVersionDetail404JSONResponse) VisitGetJobVersionDetailResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PublishJobVersionRequestObject struct {
	JobId     string `json:"job_id"`
	VersionId string `json:"version_id"`
	Params    PublishJobVersionParams
}

type PublishJobVersionResponseObject interface {
	VisitPublishJobVersionResponse(w http.ResponseWriter) error
}

type PublishJobVersion200JSONResponse JobVersion

func (response PublishJobVersion200JSONResponse) VisitPublishJobVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PublishJobVersion401JSONResponse struct{ ErrorResponseJSONResponse }

func (response PublishJobVersion401JSONResponse) VisitPublishJobVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PublishJobVersion404JSONResponse ErrorResponse

func (response PublishJobVersion404JSONResponse) VisitPublishJobVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PublishJobVersion409JSONResponse ErrorResponse

func (response PublishJobVersion409JSONResponse) VisitPublishJobVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type ListModuleTypesRequestObject struct {
	Params ListModuleTypesParams
}

type ListModuleTypesResponseObject interface {
	VisitListModuleTypesResponse(w http.ResponseWriter) error
}

type ListModuleTypes200JSONResponse struct {
	Items []ModuleType `json:"items"`
}

func (response ListModuleTypes200JSONResponse) VisitListModuleTypesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListModuleTypes401JSONResponse struct{ ErrorResponseJSONResponse }

func (response ListModuleTypes401JSONResponse) VisitListModuleTypesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type CreateModuleTypeRequestObject struct {
	Params CreateModuleTypeParams
	Body   *CreateModuleTypeJSONRequestBody
}

type CreateModuleTypeResponseObject interface {
	VisitCreateModuleTypeResponse(w http.ResponseWriter) error
}

type CreateModuleType201JSONResponse ModuleType

func (response CreateModuleType201JSONResponse) VisitCreateModuleTypeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type CreateModuleType400JSONResponse struct{ ErrorResponseJSONResponse }

func (response CreateModuleType400JSONResponse) VisitCreateModuleTypeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreateModuleType401JSONResponse ErrorResponse

func (response CreateModuleType401JSONResponse) VisitCreateModuleTypeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type CreateModuleType409JSONResponse ErrorResponse

func (response CreateModuleType409JSONResponse) VisitCreateModuleTypeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type GetModuleTypeRequestObject struct {
	Id     string `json:"id"`
	Params GetModuleTypeParams
}

type GetModuleTypeResponseObject interface {
	VisitGetModuleTypeResponse(w http.ResponseWriter) error
}

type GetModuleType200JSONResponse ModuleType

func (response GetModuleType200JSONResponse) VisitGetModuleTypeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetModuleType401JSONResponse struct{ ErrorResponseJSONResponse }

func (response GetModuleType401JSONResponse) VisitGetModuleTypeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetModuleType404JSONResponse ErrorResponse

func (response GetModuleType404JSONResponse) VisitGetModuleTypeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ListModuleTypeSchemasRequestObject struct {
	Id     string `json:"id"`
	Params ListModuleTypeSchemasParams
}

type ListModuleTypeSchemasResponseObject interface {
	VisitListModuleTypeSchemasResponse(w http.ResponseWriter) error
}

type ListModuleTypeSchemas200JSONResponse struct {
	Items []ModuleTypeSchema `json:"items"`
}

func (response ListModuleTypeSchemas200JSONResponse) VisitListModuleTypeSchemasResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListModuleTypeSchemas401JSONResponse struct{ ErrorResponseJSONResponse }

func (response ListModuleTypeSchemas401JSONResponse) VisitListModuleTypeSchemasResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type CreateModuleTypeSchemaRequestObject struct {
	Id     string `json:"id"`
	Params CreateModuleTypeSchemaParams
	Body   *CreateModuleTypeSchemaJSONRequestBody
}

type CreateModuleTypeSchemaResponseObject interface {
	VisitCreateModuleTypeSchemaResponse(w http.ResponseWriter) error
}

type CreateModuleTypeSchema201JSONResponse ModuleTypeSchema

func (response CreateModuleTypeSchema201JSONResponse) VisitCreateModuleTypeSchemaResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type CreateModuleTypeSchema400JSONResponse struct{ ErrorResponseJSONResponse }

func (response CreateModuleTypeSchema400JSONResponse) VisitCreateModuleTypeSchemaResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreateModuleTypeSchema401JSONResponse ErrorResponse

func (response CreateModuleTypeSchema401JSONResponse) VisitCreateModuleTypeSchemaResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type CreateModuleTypeSchema404JSONResponse ErrorResponse

func (response CreateModuleTypeSchema404JSONResponse) VisitCreateModuleTypeSchemaResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetHealthzRequestObject struct {
}

type GetHealthzResponseObject interface {
	VisitGetHealthzResponse(w http.ResponseWriter) error
}

type GetHealthz200JSONResponse HealthResponse

func (response GetHealthz200JSONResponse) VisitGetHealthzResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Login
	// (POST /api/v1/auth/login)
	Login(ctx context.Context, request LoginRequestObject) (LoginResponseObject, error)
	// Current user profile
	// (GET /api/v1/auth/me)
	Me(ctx context.Context, request MeRequestObject) (MeResponseObject, error)
	// Register user
	// (POST /api/v1/auth/register)
	Register(ctx context.Context, request RegisterRequestObject) (RegisterResponseObject, error)
	// List connections
	// (GET /api/v1/connections)
	ListConnections(ctx context.Context, request ListConnectionsRequestObject) (ListConnectionsResponseObject, error)
	// Create connection
	// (POST /api/v1/connections)
	CreateConnection(ctx context.Context, request CreateConnectionRequestObject) (CreateConnectionResponseObject, error)
	// Delete connection
	// (DELETE /api/v1/connections/{id})
	DeleteConnection(ctx context.Context, request DeleteConnectionRequestObject) (DeleteConnectionResponseObject, error)
	// Get connection
	// (GET /api/v1/connections/{id})
	GetConnection(ctx context.Context, request GetConnectionRequestObject) (GetConnectionResponseObject, error)
	// Update connection
	// (PUT /api/v1/connections/{id})
	UpdateConnection(ctx context.Context, request UpdateConnectionRequestObject) (UpdateConnectionResponseObject, error)
	// Ingest event
	// (POST /api/v1/events)
	IngestEvent(ctx context.Context, request IngestEventRequestObject) (IngestEventResponseObject, error)
	// List job runs
	// (GET /api/v1/job_runs)
	ListJobRuns(ctx context.Context, request ListJobRunsRequestObject) (ListJobRunsResponseObject, error)
	// Create job run
	// (POST /api/v1/job_runs)
	CreateJobRun(ctx context.Context, request CreateJobRunRequestObject) (CreateJobRunResponseObject, error)
	// Get job run by ID
	// (GET /api/v1/job_runs/{id})
	GetJobRun(ctx context.Context, request GetJobRunRequestObject) (GetJobRunResponseObject, error)
	// List jobs
	// (GET /api/v1/jobs)
	ListJobs(ctx context.Context, request ListJobsRequestObject) (ListJobsResponseObject, error)
	// Create job
	// (POST /api/v1/jobs)
	CreateJob(ctx context.Context, request CreateJobRequestObject) (CreateJobResponseObject, error)
	// Get job
	// (GET /api/v1/jobs/{id})
	GetJob(ctx context.Context, request GetJobRequestObject) (GetJobResponseObject, error)
	// Update job
	// (PUT /api/v1/jobs/{id})
	UpdateJob(ctx context.Context, request UpdateJobRequestObject) (UpdateJobResponseObject, error)
	// List job versions
	// (GET /api/v1/jobs/{job_id}/versions)
	ListJobVersions(ctx context.Context, request ListJobVersionsRequestObject) (ListJobVersionsResponseObject, error)
	// Create job version (with modules and edges)
	// (POST /api/v1/jobs/{job_id}/versions)
	CreateJobVersion(ctx context.Context, request CreateJobVersionRequestObject) (CreateJobVersionResponseObject, error)
	// Get job version detail (with modules and edges)
	// (GET /api/v1/jobs/{job_id}/versions/{version_id})
	GetJobVersionDetail(ctx context.Context, request GetJobVersionDetailRequestObject) (GetJobVersionDetailResponseObject, error)
	// Publish job version
	// (POST /api/v1/jobs/{job_id}/versions/{version_id}/publish)
	PublishJobVersion(ctx context.Context, request PublishJobVersionRequestObject) (PublishJobVersionResponseObject, error)
	// List module types
	// (GET /api/v1/module_types)
	ListModuleTypes(ctx context.Context, request ListModuleTypesRequestObject) (ListModuleTypesResponseObject, error)
	// Create module type
	// (POST /api/v1/module_types)
	CreateModuleType(ctx context.Context, request CreateModuleTypeRequestObject) (CreateModuleTypeResponseObject, error)
	// Get module type
	// (GET /api/v1/module_types/{id})
	GetModuleType(ctx context.Context, request GetModuleTypeRequestObject) (GetModuleTypeResponseObject, error)
	// List module type schema versions
	// (GET /api/v1/module_types/{id}/schemas)
	ListModuleTypeSchemas(ctx context.Context, request ListModuleTypeSchemasRequestObject) (ListModuleTypeSchemasResponseObject, error)
	// Create module type schema version
	// (POST /api/v1/module_types/{id}/schemas)
	CreateModuleTypeSchema(ctx context.Context, request CreateModuleTypeSchemaRequestObject) (CreateModuleTypeSchemaResponseObject, error)
	// Health check
	// (GET /healthz)
	GetHealthz(ctx context.Context, request GetHealthzRequestObject) (GetHealthzResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// Login operation middleware
func (sh *strictHandler) Login(w http.ResponseWriter, r *http.Request) {
	var request LoginRequestObject

	var body LoginJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.Login(ctx, request.(LoginRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "Login")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(LoginResponseObject); ok {
		if err := validResponse.VisitLoginResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Me operation middleware
func (sh *strictHandler) Me(w http.ResponseWriter, r *http.Request) {
	var request MeRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.Me(ctx, request.(MeRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "Me")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(MeResponseObject); ok {
		if err := validResponse.VisitMeResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Register operation middleware
func (sh *strictHandler) Register(w http.ResponseWriter, r *http.Request) {
	var request RegisterRequestObject

	var body RegisterJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.Register(ctx, request.(RegisterRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "Register")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(RegisterResponseObject); ok {
		if err := validResponse.VisitRegisterResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListConnections operation middleware
func (sh *strictHandler) ListConnections(w http.ResponseWriter, r *http.Request, params ListConnectionsParams) {
	var request ListConnectionsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListConnections(ctx, request.(ListConnectionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListConnections")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListConnectionsResponseObject); ok {
		if err := validResponse.VisitListConnectionsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateConnection operation middleware
func (sh *strictHandler) CreateConnection(w http.ResponseWriter, r *http.Request, params CreateConnectionParams) {
	var request CreateConnectionRequestObject

	request.Params = params

	var body CreateConnectionJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreateConnection(ctx, request.(CreateConnectionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateConnection")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreateConnectionResponseObject); ok {
		if err := validResponse.VisitCreateConnectionResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteConnection operation middleware
func (sh *strictHandler) DeleteConnection(w http.ResponseWriter, r *http.Request, id string, params DeleteConnectionParams) {
	var request DeleteConnectionRequestObject

	request.Id = id
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteConnection(ctx, request.(DeleteConnectionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteConnection")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteConnectionResponseObject); ok {
		if err := validResponse.VisitDeleteConnectionResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetConnection operation middleware
func (sh *strictHandler) GetConnection(w http.ResponseWriter, r *http.Request, id string, params GetConnectionParams) {
	var request GetConnectionRequestObject

	request.Id = id
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetConnection(ctx, request.(GetConnectionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetConnection")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetConnectionResponseObject); ok {
		if err := validResponse.VisitGetConnectionResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdateConnection operation middleware
func (sh *strictHandler) UpdateConnection(w http.ResponseWriter, r *http.Request, id string, params UpdateConnectionParams) {
	var request UpdateConnectionRequestObject

	request.Id = id
	request.Params = params

	var body UpdateConnectionJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateConnection(ctx, request.(UpdateConnectionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateConnection")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UpdateConnectionResponseObject); ok {
		if err := validResponse.VisitUpdateConnectionResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// IngestEvent operation middleware
func (sh *strictHandler) IngestEvent(w http.ResponseWriter, r *http.Request, params IngestEventParams) {
	var request IngestEventRequestObject

	request.Params = params

	var body IngestEventJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.IngestEvent(ctx, request.(IngestEventRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "IngestEvent")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(IngestEventResponseObject); ok {
		if err := validResponse.VisitIngestEventResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListJobRuns operation middleware
func (sh *strictHandler) ListJobRuns(w http.ResponseWriter, r *http.Request, params ListJobRunsParams) {
	var request ListJobRunsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListJobRuns(ctx, request.(ListJobRunsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListJobRuns")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListJobRunsResponseObject); ok {
		if err := validResponse.VisitListJobRunsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateJobRun operation middleware
func (sh *strictHandler) CreateJobRun(w http.ResponseWriter, r *http.Request, params CreateJobRunParams) {
	var request CreateJobRunRequestObject

	request.Params = params

	var body CreateJobRunJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreateJobRun(ctx, request.(CreateJobRunRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateJobRun")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreateJobRunResponseObject); ok {
		if err := validResponse.VisitCreateJobRunResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetJobRun operation middleware
func (sh *strictHandler) GetJobRun(w http.ResponseWriter, r *http.Request, id string, params GetJobRunParams) {
	var request GetJobRunRequestObject

	request.Id = id
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetJobRun(ctx, request.(GetJobRunRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetJobRun")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetJobRunResponseObject); ok {
		if err := validResponse.VisitGetJobRunResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListJobs operation middleware
func (sh *strictHandler) ListJobs(w http.ResponseWriter, r *http.Request, params ListJobsParams) {
	var request ListJobsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListJobs(ctx, request.(ListJobsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListJobs")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListJobsResponseObject); ok {
		if err := validResponse.VisitListJobsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateJob operation middleware
func (sh *strictHandler) CreateJob(w http.ResponseWriter, r *http.Request, params CreateJobParams) {
	var request CreateJobRequestObject

	request.Params = params

	var body CreateJobJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreateJob(ctx, request.(CreateJobRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateJob")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreateJobResponseObject); ok {
		if err := validResponse.VisitCreateJobResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetJob operation middleware
func (sh *strictHandler) GetJob(w http.ResponseWriter, r *http.Request, id string, params GetJobParams) {
	var request GetJobRequestObject

	request.Id = id
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetJob(ctx, request.(GetJobRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetJob")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetJobResponseObject); ok {
		if err := validResponse.VisitGetJobResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdateJob operation middleware
func (sh *strictHandler) UpdateJob(w http.ResponseWriter, r *http.Request, id string, params UpdateJobParams) {
	var request UpdateJobRequestObject

	request.Id = id
	request.Params = params

	var body UpdateJobJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateJob(ctx, request.(UpdateJobRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateJob")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UpdateJobResponseObject); ok {
		if err := validResponse.VisitUpdateJobResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListJobVersions operation middleware
func (sh *strictHandler) ListJobVersions(w http.ResponseWriter, r *http.Request, jobId string, params ListJobVersionsParams) {
	var request ListJobVersionsRequestObject

	request.JobId = jobId
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListJobVersions(ctx, request.(ListJobVersionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListJobVersions")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListJobVersionsResponseObject); ok {
		if err := validResponse.VisitListJobVersionsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateJobVersion operation middleware
func (sh *strictHandler) CreateJobVersion(w http.ResponseWriter, r *http.Request, jobId string, params CreateJobVersionParams) {
	var request CreateJobVersionRequestObject

	request.JobId = jobId
	request.Params = params

	var body CreateJobVersionJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreateJobVersion(ctx, request.(CreateJobVersionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateJobVersion")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreateJobVersionResponseObject); ok {
		if err := validResponse.VisitCreateJobVersionResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetJobVersionDetail operation middleware
func (sh *strictHandler) GetJobVersionDetail(w http.ResponseWriter, r *http.Request, jobId string, versionId string, params GetJobVersionDetailParams) {
	var request GetJobVersionDetailRequestObject

	request.JobId = jobId
	request.VersionId = versionId
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetJobVersionDetail(ctx, request.(GetJobVersionDetailRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetJobVersionDetail")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetJobVersionDetailResponseObject); ok {
		if err := validResponse.VisitGetJobVersionDetailResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PublishJobVersion operation middleware
func (sh *strictHandler) PublishJobVersion(w http.ResponseWriter, r *http.Request, jobId string, versionId string, params PublishJobVersionParams) {
	var request PublishJobVersionRequestObject

	request.JobId = jobId
	request.VersionId = versionId
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PublishJobVersion(ctx, request.(PublishJobVersionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PublishJobVersion")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PublishJobVersionResponseObject); ok {
		if err := validResponse.VisitPublishJobVersionResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListModuleTypes operation middleware
func (sh *strictHandler) ListModuleTypes(w http.ResponseWriter, r *http.Request, params ListModuleTypesParams) {
	var request ListModuleTypesRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListModuleTypes(ctx, request.(ListModuleTypesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListModuleTypes")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListModuleTypesResponseObject); ok {
		if err := validResponse.VisitListModuleTypesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateModuleType operation middleware
func (sh *strictHandler) CreateModuleType(w http.ResponseWriter, r *http.Request, params CreateModuleTypeParams) {
	var request CreateModuleTypeRequestObject

	request.Params = params

	var body CreateModuleTypeJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreateModuleType(ctx, request.(CreateModuleTypeRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateModuleType")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreateModuleTypeResponseObject); ok {
		if err := validResponse.VisitCreateModuleTypeResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetModuleType operation middleware
func (sh *strictHandler) GetModuleType(w http.ResponseWriter, r *http.Request, id string, params GetModuleTypeParams) {
	var request GetModuleTypeRequestObject

	request.Id = id
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetModuleType(ctx, request.(GetModuleTypeRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetModuleType")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetModuleTypeResponseObject); ok {
		if err := validResponse.VisitGetModuleTypeResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListModuleTypeSchemas operation middleware
func (sh *strictHandler) ListModuleTypeSchemas(w http.ResponseWriter, r *http.Request, id string, params ListModuleTypeSchemasParams) {
	var request ListModuleTypeSchemasRequestObject

	request.Id = id
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListModuleTypeSchemas(ctx, request.(ListModuleTypeSchemasRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListModuleTypeSchemas")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListModuleTypeSchemasResponseObject); ok {
		if err := validResponse.VisitListModuleTypeSchemasResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateModuleTypeSchema operation middleware
func (sh *strictHandler) CreateModuleTypeSchema(w http.ResponseWriter, r *http.Request, id string, params CreateModuleTypeSchemaParams) {
	var request CreateModuleTypeSchemaRequestObject

	request.Id = id
	request.Params = params

	var body CreateModuleTypeSchemaJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreateModuleTypeSchema(ctx, request.(CreateModuleTypeSchemaRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateModuleTypeSchema")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreateModuleTypeSchemaResponseObject); ok {
		if err := validResponse.VisitCreateModuleTypeSchemaResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetHealthz operation middleware
func (sh *strictHandler) GetHealthz(w http.ResponseWriter, r *http.Request) {
	var request GetHealthzRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetHealthz(ctx, request.(GetHealthzRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetHealthz")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetHealthzResponseObject); ok {
		if err := validResponse.VisitGetHealthzResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}
